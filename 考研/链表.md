## 链表

1. 给定两个单链表，编写算法找出两个链表的公共结点。

   分别遍历两个链表得到它们的长度，然后求出两个长度的差。在长链表上先遍历查长度之差个结点后，再同步遍历两个链表，直到找出相同的结点，或者一直到链表结束。

   ```c++
   LinkList Search_lst_Common(LinkList L1, LinkList L2) {
   	int len1 = lenth(L1), len2 = Length(L2);
   	LinkList LongList, ShortList;
   	if (len1 > len2) {
   		LongList = L1->next;
   		ShortList = L2->next;
   		dist = len1 - len2;
   	}
   	else {
   		LongList= L2->next;
   		ShortList=L1->next;
   		dist=len2-len1;
   	}
   	while(dist--)
   		LongList=LongList->next;
   	while(LongList!=NULL)
   	{
   		if(LongList!=ShortList) {
   			return LongList;
   		}
   		else {
   			LongList=LongList->next;
   			ShortList=ShortList->next;
   		}
   	}
   	return NULL;
   }
   ```

2. 两个整数序列A = a1, a2, a3, ... am， B = b1,b2,b3,..bn，已经存入两个链表中，设计一个算法，判断序列B是否是序列A的连续子序列。

   分暴力解法和字符串模式匹配算法。

3. 设计一个递归算法，删除不带头节点的单链表L中所有值为x的结点。

   ```c++
   void Del_X(LinkList &L, ElemType x) {
   	LNode *p;
   	if(L==NULL)
   	{
   		return;
   	}
   	if(L->data==x) {
   		p=L;
   		L=L->next;
   		free(p);
   		Del_X(L,x);
   	}
   	else
   		Del_X(L->next, x);
   }
   ```

   直接free掉p结点不会造成锻炼的原因，实际上因为L为引用，是直接对原链表进行操作，因此不会断链。

4. 有一个带头节点的单链表L，设计一个算法使其元素递增有序。

   采用直接插入排序算法的思想，先构成只含一个数据结点的有序单链表，然后依次扫描单链表中剩下的结点*p，在有序表中通过比较查找插入p的前驱结点pre，然后将p插入到pre之后。

   ```c++
   void Sort(LinkList &L) {
   	LNode *p = L->next, *pre;
   	LNode *r=p->next;
   	p->next=NULL;
   	p=r;
   	while(p!=NULL) {
   		r=p->next;
   		pre=L;
   		while(pre->next!=NULL&&pre->next->data<p->data)
   			pre=pre->next;
   		p->next=pre->next;
   		pre->next=p;
   		p=r;
   	}
   } 
   ```

   ​